from typing import Any, Dict, List, Tuple
import re

from langchain.chains.base import Chain

from langchain_core.runnables import RunnableConfig
from langchain_core.prompts import PromptTemplate
from langchain_core.language_models import BaseChatModel, BaseChatModel

icl_examples = {
    "tmdb": """Example 1:
User query: give me some movies performed by Tony Leung.
Plan step 1: search person with name "Tony Leung"
API response: Tony Leung's person_id is 1337
Plan step 2: collect the list of movies performed by Tony Leung whose person_id is 1337
API response: Shang-Chi and the Legend of the Ten Rings, In the Mood for Love, Hero
Thought: I am finished executing a plan and have the information the user asked for or the data the used asked to create
Final Answer: Tony Leung has performed in Shang-Chi and the Legend of the Ten Rings, In the Mood for Love, Hero

Example 2:
User query: Who wrote the screenplay for the most famous movie directed by Martin Scorsese?
Plan step 1: search for the most popular movie directed by Martin Scorsese
API response: Successfully called GET /search/person to search for the director "Martin Scorsese". The id of Martin Scorsese is 1032
Plan step 2: Continue. search for the most popular movie directed by Martin Scorsese (1032)
API response: Successfully called GET /person/{{person_id}}/movie_credits to get the most popular movie directed by Martin Scorsese. The most popular movie directed by Martin Scorsese is Shutter Island (11324)
Plan step 3: search for the screenwriter of Shutter Island
API response: The screenwriter of Shutter Island is Laeta Kalogridis (20294)
Thought: I am finished executing a plan and have the information the user asked for or the data the used asked to create
Final Answer: Laeta Kalogridis wrote the screenplay for the most famous movie directed by Martin Scorsese.
""",
    "spotify": """Example 1:
User query: set the volume to 20 and skip to the next track.
Plan step 1: set the volume to 20
API response: Successfully called PUT /me/player/volume to set the volume to 20.
Plan step 2: skip to the next track
API response: Successfully called POST /me/player/next to skip to the next track.
Thought: I am finished executing a plan and completed the user's instructions
Final Answer: I have set the volume to 20 and skipped to the next track.

Example 2:
User query: Make a new playlist called "Love Coldplay" containing the most popular songs by Coldplay
Plan step 1: search for the most popular songs by Coldplay
API response: Successfully called GET /search to search for the artist Coldplay. The id of Coldplay is 4gzpq5DPGxSnKTe4SA8HAU
Plan step 2: Continue. search for the most popular songs by Coldplay (4gzpq5DPGxSnKTe4SA8HAU)
API response: Successfully called GET /artists/4gzpq5DPGxSnKTe4SA8HAU/top-tracks to get the most popular songs by Coldplay. The most popular songs by Coldplay are Yellow (3AJwUDP919kvQ9QcozQPxg), Viva La Vida (1mea3bSkSGXuIRvnydlB5b).
Plan step 3: make a playlist called "Love Coldplay"
API response: Successfully called GET /me to get the user id. The user id is xxxxxxxxx.
Plan step 4: Continue. make a playlist called "Love Coldplay"
API response: Successfully called POST /users/xxxxxxxxx/playlists to make a playlist called "Love Coldplay". The playlist id is 7LjHVU3t3fcxj5aiPFEW4T.
Plan step 5: Add the most popular songs by Coldplay, Yellow (3AJwUDP919kvQ9QcozQPxg), Viva La Vida (1mea3bSkSGXuIRvnydlB5b), to playlist "Love Coldplay" (7LjHVU3t3fcxj5aiPFEW4T)
API response: Successfully called POST /playlists/7LjHVU3t3fcxj5aiPFEW4T/tracks to add Yellow (3AJwUDP919kvQ9QcozQPxg), Viva La Vida (1mea3bSkSGXuIRvnydlB5b) in playlist "Love Coldplay" (7LjHVU3t3fcxj5aiPFEW4T). The playlist id is 7LjHVU3t3fcxj5aiPFEW4T.
Thought: I am finished executing a plan and have the data the used asked to create
Final Answer: I have made a new playlist called "Love Coldplay" containing Yellow and Viva La Vida by Coldplay.
""",
}


PLANNER_PROMPT = """You are the "Planner" (P) an agent that plans solutions to user query $q$. In each step $t$, you generate a subtask $p_t$, a natural language description of the task to be performed.
$p_t$ is based on:

1) The user instruction $q$.
2) the previous natural language plans ($p_1, p_2, ..., p_t-1$) generated by the "Planner" (P).
3) The previous executions results ($r_1, r_2, ..., r_t-1$) from the "Executor" in natural language

Then, the "Selector" (S) reads the descriptions of available
API endpoints to select one unique appropriate API and construct the finer API plan $a_t$ which will be executed by the "Executor" (E).

You work in coordination with (E) and (S) and you are responsible to monitor the execution results of (E).

The process is as follows:
NL Plan: p_t = P(q; (p_1 , r_1), ... , (p_t-1 , r_t-1) ),
API Plan: a_t = S(p_t ; r_1 , ... , r_t-1 ),
Exec. Res.: r_t = E(a_t ; r_1 , ... , r_t-1 )

Furthermore, you have to control that the latest execution result $r_t-1$ fullfills the latest task $p_t-1$. If not, you should output "Continue" and provide a special plan $p_t$ to S requesting him to fullfil the task $p_t-1$.

In such case, (S) will regenerate a new API plan based on
the original plan $p_t-1$,
the new NL plan $p_t$,
and the previous execution results ($r_1, ..., r_t-1$).

This process is described as:
API Plan: a_t = ($p_t-1 , p_t ; r_1 , ..., r_t-1 ; a_t-1 ),
Exec. Res.: r_t ‚Üê E(a_t ; r_1 , ... , r_t ).

Finally, if the user query $q$ has been fullfilled, you should output "!!!End!!!" and provide the final answer to the user.

More guidelines:
If you want to perform search, filter, or sort actions you will put the condition in your plan $p_t$. 
For example, if the query is "Who is the lead actor of In the Mood for Love (id 843)", instead of "Get the list of actors of In the Mood for Love", you should output "Get the lead actor of In the Mood for Love (843)". The (S) will then transmit the condition to the (E) to get the lead actor of the movie with id 843.
The plan should be as specific as possible and straightforward. It is better not to use pronouns in the plan, but to use the corresponding results obtained previously. For example, instead of "Get the most popular movie directed by this person", you should output "Get the most popular movie directed by Martin Scorsese (1032)". If you want to iteratively query something about items in a list, then the list and the elements in the list should also appear in your plan.

When you need to perform repetitive actions over a list of items (e.g., retrieving tracks for each playlist), you should create a new plan step for each individual action on an item. Do not combine multiple API calls into a single plan step.


Input:

User query ($q$): {input}
History (($p_1,...,p_t-1$)+($r_1,...,r_t-1$)): {agent_scratchpad}

Output:

Starting below, you should follow this format:

Plan step <t>: <your natural language plan for step <t>>

Begin!"""


class Planner(Chain):
    """Chain that plans steps for solving API-related queries."""

    llm: BaseChatModel
    scenario: str
    planner_prompt: str
    output_key: str = "result"

    def __init__(
        self,
        llm: BaseChatModel,
        scenario: str,
        planner_prompt=PLANNER_PROMPT,
        **kwargs: Any,
    ) -> None:
        init_args = {
            "llm": llm,
            "scenario": scenario,
            "planner_prompt": planner_prompt,
            **kwargs,
        }
        super().__init__(**init_args)

    @property
    def _chain_type(self) -> str:
        return "RestGPT Planner"

    @property
    def input_keys(self) -> List[str]:
        return ["input"]

    @property
    def output_keys(self) -> List[str]:
        return [self.output_key]

    @property
    def observation_prefix(self) -> str:
        """Prefix to append the observation with."""
        return "API response: "

    @property
    def llm_prefix(self) -> str:
        """Prefix to append the llm call with."""
        return "Plan step {}: "

    @property
    def _stop(self) -> List[str]:
        return [
            f"\n{self.observation_prefix.rstrip()}",
            f"\n\t{self.observation_prefix.rstrip()}",
        ]

    def _construct_scratchpad(self, history: List[Tuple[str, str]]) -> str:
        if len(history) == 0:
            return ""
        scratchpad = ""
        for i, (plan, execution_res) in enumerate(history):
            scratchpad += self.llm_prefix.format(i + 1) + plan + "\n"
            scratchpad += self.observation_prefix + execution_res + "\n"
        return scratchpad

    def _call(self, inputs: Dict[str, str]) -> Dict[str, str]:
        scratchpad = self._construct_scratchpad(inputs["history"])
        planner_prompt = PromptTemplate(
            template=self.planner_prompt,
            partial_variables={
                "agent_scratchpad": scratchpad,
                "icl_examples": icl_examples[self.scenario],
            },
            input_variables=["input"],
        )
        planner_chain = planner_prompt | self.llm

        planner_chain_output = planner_chain.invoke(
            {
                "input": inputs["input"],
                "stop": self._stop,
            },
            RunnableConfig(tags=["stop-handling"]),
        ).content
        planner_chain_output = re.sub(
            r"Plan step \d+: ", "", planner_chain_output
        ).strip()

        return {"result": planner_chain_output}
